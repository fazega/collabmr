
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
  <script src="math.min.js" type="text/javascript"></script>
  <script src="testDev.js" type="text/javascript"></script>
   <script src="C:/Windows/System32/bower_components/mnist/dist/mnist.js" type="text/javascript"></script>
   
   <div id="page-wrapper">

        <h1>Text File Reader</h1>
        <div>
            Select a text file: 
            <input type="file" id="fileInput">
        </div>
        <pre id="fileDisplayArea"></pre>

    </div>
<script>
window.onload = function() {
        var fileInput = document.getElementById('fileInput');
        fileInput.addEventListener('change', function(e) {
            var file = fileInput.files[0];
            var textType = /text.*/;
            if (file.type.match(textType)) {
                var reader = new FileReader();
                reader.onload = function(e) {
                   console.log(reader.result);
                }
                reader.readAsText(file);    
            } else {
                console.log("File not supported!");
            }
        });
}

</script>
   
   <script>
   
function read_dataset(size_training, size_testing){
	var total = size_training + size_testing;
	if(total > 10000){
		size_training = Math.floor(size_training*(total/10000));
		size_testing = Math.floor(size_testing*(total/10000));
	}
	var set = mnist.set(size_training, size_testing);
	var trainingSet = set.training;
	var testSet = set.test;
	return [trainingSet, testSet];
}



function predict(ThetaRes, X){
    var m = X.size()[0];
    var num_labels = ThetaRes[ThetaRes.length-1].size()[0];
    var num_layers = ThetaRes.length + 1;

   
    var p = [];
 
    for(k=0;k<m;k++){
        var h=math.matrix(X._data[k]);
        for(index=0;index<(num_layers-1);index++){
            h=sigmoid(math.multiply(ThetaRes[index],math.matrix([1].concat(h._data))));
		}
		var max = math.max(h);
		
		for(j=0; j<h.size()[0];j++){
			if(h._data[j] == max){
				p.push(j);
			}
		}
    
	}
	return p;
}
function randInitializeWeights(layers){

    var num_of_layers = layers.length;
    var epsilon = 0.12;
    var Theta = []
	console.log("Theta shape:");
	console.log(layers[1],layers[0] + 1);
    for(i=0; i<num_of_layers-1; i++){
        var W = math.zeros(math.abs(layers[i+1]),math.abs(layers[i] + 1));

        for(j=0;j<W.size()[0];j++){

			for(k=0; k<W.size()[1];k++){
				W._data[j][k]=(Math.random()*2*epsilon - epsilon);
			}  
		}
        Theta.push(W)
    }
    return Theta;
	
}

function sigmoidGradient(z){
	//console.log("gradient");
	//console.log(z);
	var n = z.size()[0];
	var g = sigmoid(z);
	for(j = 0; j<n; j++){
		g._data[j] = g._data[j]*(1-g._data[j]);
	}
	return g;
}
    
function sigmoid(z){
	var n = z.size()[0];
    var g = math.zeros(n);
	for(j = 0; j<n; j++){
		g._data[j] = (1.0)/(1.0+math.exp(-z._data[j]));
	}
    return g;
	}	

function backwards2(Theta, layers, X, y, num_labels, lambd){
	
    var m = X.size()[0];
    var num_layers = layers.length;
	var Theta_grad = [];
	var J = 0;
	for(i=0;i<Theta.length;i++){
		Theta_grad.push(math.zeros(Theta[i].size()));
	}

    //console.log("debug back Theta");
	//console.log(Theta);
	
    // In this point implement the backpropagation algorithm     
    for(i=0;i<m;i++){
	    A = [];
        Z = [];
        A.push(X._data[i]);
        Z.push([0]);
        for(j=0;j<num_layers-1;j++){
			Z.push(math.multiply(Theta[j],math.matrix([1].concat(A[j]))));
			//console.log("Xi");
			//console.log(X._data[i]);
            A.push(sigmoid(Z[j+1])._data);
		}
        
		// Cost computation for each training example (without regularization)
		for(k=0;k<num_labels;k++){
			
            J += (-1)*y._data[i][k]*math.log(A[A.length-1][k])-(1-y._data[i][k])*math.log(1-A[A.length-1][k]);
		}
		
        var D = [];
		temp = [];
		for(k=0; k<num_labels;k++){
			temp.push(A[A.length-1][k]-y._data[i][k]);
		}
        D.push(temp);
        var j=num_layers-2;
        while(j>0){
			var temp1 = math.subset(Theta[j],math.index(math.range(0,Theta[j].size()[0]),math.range(1,Theta[j].size()[1])));
		    var tempList = math.multiply(math.transpose(temp1),math.matrix(D[0]));
			var sig =sigmoidGradient(Z[j])._data;
			for(k=0; k<tempList.size()[0];k++){
				tempList._data[k] *= sig[k];
			}
			D=[tempList._data].concat(D);
			j--;
		}

        for(l=0;l<Theta_grad.length;l++){
			for(n =0; n<D[l].length;n++){
				D[l][n]*=1.0/m;
			}
			var  temp1 =math.transpose(math.matrix([D[l]]));
			//console.log(temp1);
			var temp2 =math.matrix([[1].concat(A[l])]);
			//console.log(temp2);
			var temp3 = math.multiply(temp1,temp2);
			//console.log(Theta_grad[l],temp3);
		    Theta_grad[l] = math.add(Theta_grad[l],temp3);
		}
    
	}
	
    //regularization
	
    for(i = 0; i<num_layers - 1; i++){
		var temp_matrix = Theta[i];
		for(j = 0; j< Theta[i].size()[0]; j++){
			temp_matrix._data[j][0] = 0;
		}
		Theta_grad[i] = math.add(Theta_grad[i],math.multiply((lambd/m),temp_matrix));
	} 

	// Cost regularization
	J*=(1.0/m);
    var JR=0;
    for(i=0;i<Theta.length;i++){
        for(j=0;j<Theta[i].size()[0];j++){
		    for(k=0; k<Theta[i].size()[1];k++){
				    JR+=Theta[i]._data[j][k]*Theta[i]._data[j][k];
			}
            
		}
    }
	JR*=lambd/(2*m);
    
	J += JR;
	
	console.log("Cost J = ");
	console.log(J);
	
    return Theta_grad;

}

function train(nb_epochs,eta,Theta,layers,X,y,num_labels,lambd,early_stopping){
	
	var Theta_grad;
	for(e=0; e<nb_epochs;e++){
		console.log("Epoch number : ");
		console.log(e);
		Theta_grad = backwards2(Theta,layers,X,y,num_labels,lambd);
		for(l=0;l<Theta_grad.length;l++){
			Theta_grad[l] = math.multiply(Theta_grad[l],(-1)*eta);
			Theta[l] = math.add(Theta[l],Theta_grad[l]);
		}
	}
	return Theta;
}

// MAIN :
//Reading of the dataset
// You are free to reduce the number of samples retained for training, in order to reduce the computational cost
var size_training = 8000;//60000;
var size_test     = 2000;//10000;

var read = read_dataset(size_training, size_test);
var images_training = [];
var labels_training= [];
var images_test = [];
var labels_test = [];

for(i=0;i<read[0].length;i++){
	images_training.push(read[0][i].input);
	labels_training.push(read[0][i].output);
}
for(i=0;i<read[1].length;i++){
	images_test.push(read[1][i].input);
	labels_test.push(read[1][i].output);
}
var X = math.matrix(images_training);
var y = math.matrix(labels_training);
console.log("y");
console.log(y);
var input_layer_size   = 784;        // 28x28 Input Images of Digits
var num_labels         = 10;        //10 labels, from 0 to 9 (one label for each digit) 

var num_of_hidden_layers = 1; //change here
var layers = [input_layer_size];
for(i=0; i<num_of_hidden_layers;i++){
    layers.push(100); // nb nodes per layer
}
layers.push(num_labels);

console.log("\nInitializing Neural Network Parameters ...\n");


// test if needed
//test();


console.log("\nTraining Neural Network... \n");

var lambd = 3.0

// ----- Training of the neural network -----
var nb_epochs = 100;
var eta = 0.1;
var early_stopping = 5;
var Theta = randInitializeWeights(layers);

var ThetaRes = train(nb_epochs,eta,Theta,layers,X,y,num_labels,lambd,early_stopping);

console.log("\nTesting Neural Network... \n");

var pred  = predict(ThetaRes, math.matrix(images_test));
var accuracy = 0.0;

console.log(pred);
for(w = 0; w<size_test;w++){
	if(pred[w] == labels_test[w].indexOf(1)){
		accuracy += 1.0;
		
	}
	
	
}

console.log('\nAccuracy: ' + accuracy*100.0/size_test);


   
	</script>
   <div id='main'>
   <p>hello, welcome to MapMine</p>
   </div>